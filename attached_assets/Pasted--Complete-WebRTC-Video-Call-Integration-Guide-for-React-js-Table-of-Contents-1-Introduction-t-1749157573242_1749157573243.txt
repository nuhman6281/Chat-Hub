# Complete WebRTC Video Call Integration Guide for React.js

## Table of Contents
1. [Introduction to WebRTC](#introduction-to-webrtc)
2. [Architecture Overview](#architecture-overview)
3. [Setting Up Development Environment](#setting-up-development-environment)
4. [Core Components Implementation](#core-components-implementation)
5. [Signaling Server Implementation](#signaling-server-implementation)
6. [React Client Implementation](#react-client-implementation)
7. [STUN/TURN Server Configuration](#stunturn-server-configuration)
8. [Advanced Features](#advanced-features)
9. [Error Handling & Best Practices](#error-handling--best-practices)
10. [Security Considerations](#security-considerations)
11. [Deployment & Production](#deployment--production)
12. [Troubleshooting Guide](#troubleshooting-guide)

---

## 1. Introduction to WebRTC

### What is WebRTC?
WebRTC (Web Real-Time Communication) is an open framework that enables Real-Time Communications (RTC) capabilities in the browser, supporting video, voice, and generic data to be sent between peers. It enables Web applications and sites to capture and optionally stream audio and/or video media, as well as to exchange arbitrary data between browsers without requiring an intermediary.

### Key Advantages
- **Direct Peer-to-Peer Communication**: With WebRTC, the client can directly communicate with each other and completely bypass the server. This in turn decreases latency by a lot because the receiving client doesn't have to wait for the server
- **No Plugin Required**: Built into modern browsers
- **Real-time Performance**: Minimal latency for media transmission
- **Cross-platform Support**: Works on web, mobile, and desktop

### Core WebRTC APIs
The core components include RTCPeerConnection (manages the connection between two peers), RTCDataChannel (allows bidirectional data exchange between peers), and MediaStream (handles streams of audio or video).

---

## 2. Architecture Overview

### WebRTC Connection Flow
A simple graph will visualize steps on how webRTC can establish the connection. First, Peer-1 creates an Offer containing SDP and ICE Candidates generated by WebRTC API and sends it to the Signaling Server. Meanwhile, Peer-2 listens to the Signaling server to receive the incoming Offer. After receiving the Peer-1's Offer, Peer-2 creates an Answer which also contains the same structure data and sends it back to the Signaling Server.

### Components Required
1. **Signaling Server**: For exchanging offers, answers, and ICE candidates
2. **STUN/TURN Servers**: For NAT traversal
3. **React Client**: User interface and WebRTC logic
4. **Media Devices**: Camera and microphone access

### Technology Stack
- **Frontend**: React.js, Socket.io-client, WebRTC APIs
- **Backend**: Node.js, Express, Socket.io
- **Signaling**: WebSocket for real-time communication
- **Infrastructure**: STUN/TURN servers for network traversal

---

## 3. Setting Up Development Environment

### Prerequisites
```bash
# Required software
Node.js (v16 or later)
npm or yarn
Modern browser with WebRTC support
```

### Project Initialization
```bash
# Create React application
npx create-react-app webrtc-video-chat
cd webrtc-video-chat

# Install required dependencies
npm install socket.io-client simple-peer
# or
yarn add socket.io-client simple-peer
```

### Development Dependencies
```bash
# Additional useful packages
npm install --save-dev @types/socket.io-client
```

### Project Structure
```
webrtc-video-chat/
├── src/
│   ├── components/
│   │   ├── VideoCall.js
│   │   ├── VideoPlayer.js
│   │   └── Controls.js
│   ├── context/
│   │   └── SocketContext.js
│   ├── hooks/
│   │   └── useWebRTC.js
│   └── utils/
│       └── webrtc-config.js
├── server/
│   ├── index.js
│   └── socket-handlers.js
└── package.json
```

---

## 4. Core Components Implementation

### WebRTC Configuration
```javascript
// utils/webrtc-config.js
export const ICE_SERVERS = {
  iceServers: [
    {
      urls: [
        'stun:stun1.l.google.com:19302',
        'stun:stun2.l.google.com:19302'
      ]
    },
    // Add TURN server for production
    {
      urls: 'turn:your-turn-server.com:3478',
      username: 'your-username',
      credential: 'your-password'
    }
  ],
  iceCandidatePoolSize: 10
};

export const MEDIA_CONSTRAINTS = {
  video: {
    width: { min: 640, ideal: 1280, max: 1920 },
    height: { min: 480, ideal: 720, max: 1080 },
    frameRate: { min: 16, ideal: 30, max: 60 }
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  }
};
```

### Custom WebRTC Hook
```javascript
// hooks/useWebRTC.js
import { useState, useRef, useCallback, useEffect } from 'react';
import { ICE_SERVERS, MEDIA_CONSTRAINTS } from '../utils/webrtc-config';

export const useWebRTC = (socket) => {
  const [localStream, setLocalStream] = useState(null);
  const [remoteStream, setRemoteStream] = useState(null);
  const [isCallActive, setIsCallActive] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  
  const peerConnectionRef = useRef(null);
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);

  // Initialize peer connection
  const createPeerConnection = useCallback(() => {
    try {
      const peerConnection = new RTCPeerConnection(ICE_SERVERS);
      
      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', {
            candidate: event.candidate
          });
        }
      };

      // Handle remote stream
      peerConnection.ontrack = (event) => {
        const [stream] = event.streams;
        setRemoteStream(stream);
        if (remoteVideoRef.current) {
          remoteVideoRef.current.srcObject = stream;
        }
      };

      // Handle connection state changes
      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log('Connection state:', state);
        
        if (state === 'connected') {
          setIsConnecting(false);
          setIsCallActive(true);
        } else if (state === 'disconnected' || state === 'failed') {
          endCall();
        }
      };

      peerConnectionRef.current = peerConnection;
      return peerConnection;
    } catch (error) {
      console.error('Error creating peer connection:', error);
      throw error;
    }
  }, [socket]);

  // Get user media
  const getUserMedia = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(MEDIA_CONSTRAINTS);
      setLocalStream(stream);
      
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream;
      }
      
      return stream;
    } catch (error) {
      console.error('Error accessing media devices:', error);
      throw new Error('Could not access camera/microphone');
    }
  }, []);

  // Start call
  const startCall = useCallback(async (targetUserId) => {
    try {
      setIsConnecting(true);
      
      const stream = await getUserMedia();
      const peerConnection = createPeerConnection();
      
      // Add tracks to peer connection
      stream.getTracks().forEach(track => {
        peerConnection.addTrack(track, stream);
      });
      
      // Create and send offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      
      socket.emit('call-user', {
        userToCall: targetUserId,
        signalData: offer,
        from: socket.id
      });
      
    } catch (error) {
      console.error('Error starting call:', error);
      setIsConnecting(false);
      throw error;
    }
  }, [socket, getUserMedia, createPeerConnection]);

  // Answer call
  const answerCall = useCallback(async (incomingCall) => {
    try {
      setIsConnecting(true);
      
      const stream = await getUserMedia();
      const peerConnection = createPeerConnection();
      
      // Add tracks to peer connection
      stream.getTracks().forEach(track => {
        peerConnection.addTrack(track, stream);
      });
      
      // Set remote description and create answer
      await peerConnection.setRemoteDescription(incomingCall.signalData);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      
      socket.emit('answer-call', {
        signalData: answer,
        to: incomingCall.from
      });
      
    } catch (error) {
      console.error('Error answering call:', error);
      setIsConnecting(false);
      throw error;
    }
  }, [socket, getUserMedia, createPeerConnection]);

  // End call
  const endCall = useCallback(() => {
    // Stop local stream
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    // Close peer connection
    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }
    
    // Reset state
    setLocalStream(null);
    setRemoteStream(null);
    setIsCallActive(false);
    setIsConnecting(false);
    
    socket.emit('end-call');
  }, [socket, localStream]);

  // Toggle audio/video
  const toggleAudio = useCallback(() => {
    if (localStream) {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
      }
    }
  }, [localStream]);

  const toggleVideo = useCallback(() => {
    if (localStream) {
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
      }
    }
  }, [localStream]);

  return {
    localStream,
    remoteStream,
    isCallActive,
    isConnecting,
    localVideoRef,
    remoteVideoRef,
    startCall,
    answerCall,
    endCall,
    toggleAudio,
    toggleVideo
  };
};
```

---

## 5. Signaling Server Implementation

### Express Server with Socket.io
```javascript
// server/index.js
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');

const app = express();
const server = http.createServer(app);

// Configure CORS for Socket.io
const io = socketIo(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"],
    credentials: true
  }
});

app.use(cors());
app.use(express.json());

// Store connected users
const connectedUsers = new Map();
const activeRooms = new Map();

io.on('connection', (socket) => {
  console.log(`User connected: ${socket.id}`);
  
  // Register user
  socket.on('register', (userData) => {
    connectedUsers.set(socket.id, {
      ...userData,
      socketId: socket.id
    });
    
    // Broadcast updated user list
    io.emit('users-update', Array.from(connectedUsers.values()));
  });

  // Handle call initiation
  socket.on('call-user', (data) => {
    const { userToCall, signalData, from } = data;
    console.log(`Call from ${from} to ${userToCall}`);
    
    // Forward call to target user
    socket.to(userToCall).emit('incoming-call', {
      signalData,
      from: socket.id,
      callerInfo: connectedUsers.get(socket.id)
    });
  });

  // Handle call answer
  socket.on('answer-call', (data) => {
    const { signalData, to } = data;
    console.log(`Call answered by ${socket.id} to ${to}`);
    
    socket.to(to).emit('call-answered', {
      signalData,
      from: socket.id
    });
  });

  // Handle ICE candidates
  socket.on('ice-candidate', (data) => {
    const { candidate, to } = data;
    
    if (to) {
      socket.to(to).emit('ice-candidate', {
        candidate,
        from: socket.id
      });
    } else {
      // Broadcast to all connected peers (for group calls)
      socket.broadcast.emit('ice-candidate', {
        candidate,
        from: socket.id
      });
    }
  });

  // Handle call rejection
  socket.on('reject-call', (data) => {
    const { to } = data;
    socket.to(to).emit('call-rejected', {
      from: socket.id
    });
  });

  // Handle call end
  socket.on('end-call', (data) => {
    const { to } = data;
    if (to) {
      socket.to(to).emit('call-ended', {
        from: socket.id
      });
    } else {
      socket.broadcast.emit('call-ended', {
        from: socket.id
      });
    }
  });

  // Handle room management for group calls
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
    
    if (!activeRooms.has(roomId)) {
      activeRooms.set(roomId, new Set());
    }
    
    activeRooms.get(roomId).add(socket.id);
    
    // Notify others in room
    socket.to(roomId).emit('user-joined', {
      userId: socket.id,
      userInfo: connectedUsers.get(socket.id)
    });
    
    // Send current room participants to new user
    const roomParticipants = Array.from(activeRooms.get(roomId))
      .filter(id => id !== socket.id)
      .map(id => ({
        userId: id,
        userInfo: connectedUsers.get(id)
      }));
    
    socket.emit('room-participants', roomParticipants);
  });

  socket.on('leave-room', (roomId) => {
    socket.leave(roomId);
    
    if (activeRooms.has(roomId)) {
      activeRooms.get(roomId).delete(socket.id);
      
      if (activeRooms.get(roomId).size === 0) {
        activeRooms.delete(roomId);
      }
    }
    
    socket.to(roomId).emit('user-left', {
      userId: socket.id
    });
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log(`User disconnected: ${socket.id}`);
    
    // Remove from connected users
    connectedUsers.delete(socket.id);
    
    // Remove from active rooms
    activeRooms.forEach((participants, roomId) => {
      if (participants.has(socket.id)) {
        participants.delete(socket.id);
        socket.to(roomId).emit('user-left', {
          userId: socket.id
        });
        
        if (participants.size === 0) {
          activeRooms.delete(roomId);
        }
      }
    });
    
    // Broadcast updated user list
    io.emit('users-update', Array.from(connectedUsers.values()));
    
    // Notify about disconnection
    socket.broadcast.emit('user-disconnected', socket.id);
  });

  // Error handling
  socket.on('error', (error) => {
    console.error(`Socket error for ${socket.id}:`, error);
  });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    connectedUsers: connectedUsers.size,
    activeRooms: activeRooms.size,
    timestamp: new Date().toISOString()
  });
});

const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Signaling server running on port ${PORT}`);
});

module.exports = { app, server, io };
```

---

## 6. React Client Implementation

### Socket Context Provider
```javascript
// context/SocketContext.js
import React, { createContext, useContext, useEffect, useState } from 'react';
import io from 'socket.io-client';

const SocketContext = createContext();

export const useSocket = () => {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within SocketProvider');
  }
  return context;
};

export const SocketProvider = ({ children }) => {
  const [socket, setSocket] = useState(null);
  const [connectedUsers, setConnectedUsers] = useState([]);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const newSocket = io(process.env.REACT_APP_SERVER_URL || 'http://localhost:5000', {
      transports: ['websocket'],
      autoConnect: true
    });

    newSocket.on('connect', () => {
      console.log('Connected to signaling server');
      setIsConnected(true);
    });

    newSocket.on('disconnect', () => {
      console.log('Disconnected from signaling server');
      setIsConnected(false);
    });

    newSocket.on('users-update', (users) => {
      setConnectedUsers(users);
    });

    newSocket.on('connect_error', (error) => {
      console.error('Connection error:', error);
      setIsConnected(false);
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, []);

  const value = {
    socket,
    connectedUsers,
    isConnected
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
};
```

### Main Video Call Component
```javascript
// components/VideoCall.js
import React, { useState, useEffect, useCallback } from 'react';
import { useSocket } from '../context/SocketContext';
import { useWebRTC } from '../hooks/useWebRTC';
import VideoPlayer from './VideoPlayer';
import Controls from './Controls';
import UserList from './UserList';
import CallModal from './CallModal';

const VideoCall = () => {
  const { socket, connectedUsers, isConnected } = useSocket();
  const {
    localStream,
    remoteStream,
    isCallActive,
    isConnecting,
    localVideoRef,
    remoteVideoRef,
    startCall,
    answerCall,
    endCall,
    toggleAudio,
    toggleVideo
  } = useWebRTC(socket);

  const [incomingCall, setIncomingCall] = useState(null);
  const [callError, setCallError] = useState(null);
  const [userName, setUserName] = useState('');
  const [isRegistered, setIsRegistered] = useState(false);

  // Handle incoming call
  useEffect(() => {
    if (!socket) return;

    const handleIncomingCall = (callData) => {
      console.log('Incoming call from:', callData.from);
      setIncomingCall(callData);
    };

    const handleCallAnswered = (data) => {
      console.log('Call answered:', data);
      if (socket.peerConnection) {
        socket.peerConnection.setRemoteDescription(data.signalData);
      }
    };

    const handleCallRejected = (data) => {
      console.log('Call rejected by:', data.from);
      setCallError('Call was rejected');
      endCall();
    };

    const handleCallEnded = (data) => {
      console.log('Call ended by:', data.from);
      endCall();
    };

    const handleIceCandidate = (data) => {
      console.log('Received ICE candidate:', data);
      if (socket.peerConnection && data.candidate) {
        socket.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    };

    socket.on('incoming-call', handleIncomingCall);
    socket.on('call-answered', handleCallAnswered);
    socket.on('call-rejected', handleCallRejected);
    socket.on('call-ended', handleCallEnded);
    socket.on('ice-candidate', handleIceCandidate);

    return () => {
      socket.off('incoming-call', handleIncomingCall);
      socket.off('call-answered', handleCallAnswered);
      socket.off('call-rejected', handleCallRejected);
      socket.off('call-ended', handleCallEnded);
      socket.off('ice-candidate', handleIceCandidate);
    };
  }, [socket, endCall]);

  // Register user
  const handleRegister = useCallback((name) => {
    if (socket && name.trim()) {
      setUserName(name);
      socket.emit('register', { name: name.trim() });
      setIsRegistered(true);
    }
  }, [socket]);

  // Handle call user
  const handleCallUser = useCallback(async (userId) => {
    try {
      setCallError(null);
      await startCall(userId);
    } catch (error) {
      setCallError(error.message);
    }
  }, [startCall]);

  // Handle answer call
  const handleAnswerCall = useCallback(async () => {
    try {
      setCallError(null);
      await answerCall(incomingCall);
      setIncomingCall(null);
    } catch (error) {
      setCallError(error.message);
      setIncomingCall(null);
    }
  }, [answerCall, incomingCall]);

  // Handle reject call
  const handleRejectCall = useCallback(() => {
    if (incomingCall) {
      socket.emit('reject-call', { to: incomingCall.from });
      setIncomingCall(null);
    }
  }, [socket, incomingCall]);

  // Handle end call
  const handleEndCall = useCallback(() => {
    endCall();
    setCallError(null);
  }, [endCall]);

  if (!isConnected) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p>Connecting to server...</p>
        </div>
      </div>
    );
  }

  if (!isRegistered) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-100">
        <div className="bg-white p-8 rounded-lg shadow-md w-96">
          <h2 className="text-2xl font-bold mb-4 text-center">Join Video Chat</h2>
          <form
            onSubmit={(e) => {
              e.preventDefault();
              const name = e.target.name.value;
              handleRegister(name);
            }}
          >
            <input
              type="text"
              name="name"
              placeholder="Enter your name"
              className="w-full p-3 border rounded-md mb-4"
              required
            />
            <button
              type="submit"
              className="w-full bg-blue-500 text-white p-3 rounded-md hover:bg-blue-600"
            >
              Join Chat
            </button>
          </form>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen bg-gray-900 text-white">
      <div className="container mx-auto h-full flex">
        {/* User List Sidebar */}
        <div className="w-1/4 bg-gray-800 p-4">
          <h2 className="text-xl font-bold mb-4">Online Users ({connectedUsers.length})</h2>
          <UserList
            users={connectedUsers.filter(user => user.socketId !== socket?.id)}
            onCallUser={handleCallUser}
            currentUserId={socket?.id}
          />
        </div>

        {/* Video Area */}
        <div className="flex-1 flex flex-col">
          {isCallActive || isConnecting ? (
            <div className="flex-1 flex">
              {/* Remote Video */}
              <div className="flex-1 relative">
                <VideoPlayer
                  stream={remoteStream}
                  isLocal={false}
                  videoRef={remoteVideoRef}
                />
                {isConnecting && (
                  <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
                    <div className="text-center">
                      <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
                      <p>Connecting...</p>
                    </div>
                  </div>
                )}
              </div>

              {/* Local Video (Picture-in-Picture) */}
              <div className="absolute bottom-4 right-4 w-64 h-48">
                <VideoPlayer
                  stream={localStream}
                  isLocal={true}
                  videoRef={localVideoRef}
                  muted={true}
                />
              </div>
            </div>
          ) : (
            <div className="flex-1 flex items-center justify-center">
              <div className="text-center">
                <h1 className="text-3xl font-bold mb-4">WebRTC Video Chat</h1>
                <p className="text-gray-400">Select a user from the list to start a video call</p>
              </div>
            </div>
          )}

          {/* Controls */}
          {(isCallActive || isConnecting) && (
            <Controls
              onToggleAudio={toggleAudio}
              onToggleVideo={toggleVideo}
              onEndCall={handleEndCall}
              isCallActive={isCallActive}
            />
          )}
        </div>
      </div>

      {/* Incoming Call Modal */}
      {incomingCall && (
        <CallModal
          caller={incomingCall.callerInfo}
          onAnswer={handleAnswerCall}
          onReject={handleRejectCall}
        />
      )}

      {/* Error Message */}
      {callError && (
        <div className="fixed top-4 right-4 bg-red-500 text-white p-4 rounded-md shadow-lg">
          <p>{callError}</p>
          <button
            onClick={() => setCallError(null)}
            className="ml-2 text-white hover:text-gray-200"
          >
            ×
          </button>
        </div>
      )}
    </div>
  );
};

export default VideoCall;
```

### Video Player Component
```javascript
// components/VideoPlayer.js
import React, { useEffect, useState } from 'react';

const VideoPlayer = ({ stream, isLocal, videoRef, muted = false }) => {
  const [isVideoEnabled, setIsVideoEnabled] = useState(true);
  const [isAudioEnabled, setIsAudioEnabled] = useState(true);

  useEffect(() => {
    if (videoRef?.current && stream) {
      videoRef.current.srcObject = stream;
    }

    // Monitor track enabled state
    if (stream) {
      const videoTrack = stream.getVideoTracks()[0];
      const audioTrack = stream.getAudioTracks()[0];

      if (videoTrack) {
        setIsVideoEnabled(videoTrack.enabled);
        
        // Listen for track state changes
        videoTrack.addEventListener('ended', () => setIsVideoEnabled(false));
      }

      if (audioTrack) {
        setIsAudioEnabled(audioTrack.enabled);
        audioTrack.addEventListener('ended', () => setIsAudioEnabled(false));
      }
    }
  }, [stream, videoRef]);

  if (!stream) {
    return (
      <div className="w-full h-full bg-gray-800 flex items-center justify-center rounded-lg">
        <div className="text-center">
          <div className="w-16 h-16 bg-gray-600 rounded-full flex items-center justify-center mx-auto mb-2">
            <svg className="w-8 h-8 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" />
            </svg>
          </div>
          <p className="text-gray-400 text-sm">No video</p>
        </div>
      </div>
    );
  }

  return (
    <div className="relative w-full h-full">
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted={muted}
        className={`w-full h-full object-cover rounded-lg ${
          isLocal ? 'transform scale-x-[-1]' : ''
        } ${!isVideoEnabled ? 'hidden' : ''}`}
      />
      
      {/* Video disabled overlay */}
      {!isVideoEnabled && (
        <div className="absolute inset-0 bg-gray-800 flex items-center justify-center rounded-lg">
          <div className="text-center">
            <div className="w-16 h-16 bg-gray-600 rounded-full flex items-center justify-center mx-auto mb-2">
              <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 3l18 18" />
              </svg>
            </div>
            <p className="text-gray-400 text-sm">Camera off</p>
          </div>
        </div>
      )}

      {/* Audio indicator */}
      {!isLocal && (
        <div className="absolute top-2 left-2">
          {!isAudioEnabled && (
            <div className="bg-red-500 rounded-full p-1">
              <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
              </svg>
            </div>
          )}
        </div>
      )}

      {/* Local video label */}
      {isLocal && (
        <div className="absolute bottom-2 left-2 bg-black bg-opacity-50 px-2 py-1 rounded text-xs">
          You
        </div>
      )}
    </div>
  );
};

export default VideoPlayer;
```

### Controls Component
```javascript
// components/Controls.js
import React, { useState } from 'react';

const Controls = ({ onToggleAudio, onToggleVideo, onEndCall, isCallActive }) => {
  const [isAudioEnabled, setIsAudioEnabled] = useState(true);
  const [isVideoEnabled, setIsVideoEnabled] = useState(true);

  const handleToggleAudio = () => {
    onToggleAudio();
    setIsAudioEnabled(!isAudioEnabled);
  };

  const handleToggleVideo = () => {
    onToggleVideo();
    setIsVideoEnabled(!isVideoEnabled);
  };

  return (
    <div className="bg-gray-800 p-4">
      <div className="flex justify-center space-x-4">
        {/* Microphone Toggle */}
        <button
          onClick={handleToggleAudio}
          className={`p-3 rounded-full transition-colors ${
            isAudioEnabled 
              ? 'bg-gray-600 hover:bg-gray-500 text-white' 
              : 'bg-red-500 hover:bg-red-600 text-white'
          }`}
          title={isAudioEnabled ? 'Mute microphone' : 'Unmute microphone'}
        >
          {isAudioEnabled ? (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
          ) : (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
            </svg>
          )}
        </button>

        {/* Camera Toggle */}
        <button
          onClick={handleToggleVideo}
          className={`p-3 rounded-full transition-colors ${
            isVideoEnabled 
              ? 'bg-gray-600 hover:bg-gray-500 text-white' 
              : 'bg-red-500 hover:bg-red-600 text-white'
          }`}
          title={isVideoEnabled ? 'Turn off camera' : 'Turn on camera'}
        >
          {isVideoEnabled ? (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
          ) : (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 3l18 18" />
            </svg>
          )}
        </button>

        {/* End Call */}
        <button
          onClick={onEndCall}
          className="p-3 rounded-full bg-red-500 hover:bg-red-600 text-white transition-colors"
          title="End call"
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 8l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M3 3l2.5 2.5m0 0L8 8m0 0l2.5 2.5M8 8L5.5 5.5M8 8l2.5-2.5" />
          </svg>
        </button>

        {/* Screen Share (Future Implementation) */}
        <button
          className="p-3 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors"
          title="Share screen (coming soon)"
          disabled
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
          </svg>
        </button>
      </div>
    </div>
  );
};

export default Controls;
```

---

## 7. STUN/TURN Server Configuration

### Understanding STUN/TURN Servers

**STUN (Session Traversal Utilities for NAT)** servers help devices behind NATs determine their public IP address and the NAT type they are behind. **TURN (Traversal Using Relays around NAT)** servers act as intermediaries that relay data between peers, ensuring reliable connectivity even in challenging network environments.

### Production STUN/TURN Configuration
```javascript
// utils/ice-servers.js
export const ICE_SERVERS_CONFIG = {
  development: {
    iceServers: [
      {
        urls: [
          'stun:stun1.l.google.com:19302',
          'stun:stun2.l.google.com:19302'
        ]
      }
    ]
  },
  production: {
    iceServers: [
      // Your own STUN server
      {
        urls: 'stun:your-stun-server.com:3478'
      },
      // Your own TURN server with authentication
      {
        urls: 'turn:your-turn-server.com:3478',
        username: process.env.REACT_APP_TURN_USERNAME,
        credential: process.env.REACT_APP_TURN_PASSWORD
      },
      // Backup TURN server
      {
        urls: 'turns:your-turn-server.com:5349', // TURN over TLS
        username: process.env.REACT_APP_TURN_USERNAME,
        credential: process.env.REACT_APP_TURN_PASSWORD
      }
    ]
  }
};

export const getIceServers = () => {
  const env = process.env.NODE_ENV;
  return ICE_SERVERS_CONFIG[env] || ICE_SERVERS_CONFIG.development;
};
```

### Setting Up Coturn (Self-hosted TURN Server)
```bash
# Install Coturn on Ubuntu
sudo apt update
sudo apt install coturn

# Configure Coturn
sudo nano /etc/turnserver.conf
```

```ini
# /etc/turnserver.conf
listening-port=3478
tls-listening-port=5349

# External IP (replace with your server's public IP)
external-ip=YOUR_PUBLIC_IP

# Authentication
lt-cred-mech
user=myuser:mypassword

# Realm
realm=your-domain.com

# SSL certificates for TURNS
cert=/etc/ssl/certs/turn_server_cert.pem
pkey=/etc/ssl/private/turn_server_pkey.pem

# Security
no-multicast-peers
no-cli
no-tlsv1
no-tlsv1_1

# Logging
log-file=/var/log/turnserver.log
verbose
```

### Testing STUN/TURN Servers
```javascript
// utils/ice-test.js
export const testIceServers = async (iceServers) => {
  return new Promise((resolve, reject) => {
    const pc = new RTCPeerConnection({ iceServers });
    const candidates = [];
    
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        candidates.push(event.candidate);
      } else {
        // ICE gathering complete
        pc.close();
        resolve({
          success: true,
          candidates: candidates.length,
          types: [...new Set(candidates.map(c => c.type))]
        });
      }
    };

    pc.onicegatheringstatechange = () => {
      if (pc.iceGatheringState === 'complete') {
        pc.close();
        resolve({
          success: true,
          candidates: candidates.length,
          types: [...new Set(candidates.map(c => c.type))]
        });
      }
    };

    // Create a data channel to trigger ICE gathering
    pc.createDataChannel('test');
    
    pc.createOffer()
      .then(offer => pc.setLocalDescription(offer))
      .catch(reject);

    // Timeout after 10 seconds
    setTimeout(() => {
      pc.close();
      reject(new Error('ICE gathering timeout'));
    }, 10000);
  });
};
```

---

## 8. Advanced Features

### Screen Sharing Implementation
```javascript
// hooks/useScreenShare.js
import { useState, useCallback } from 'react';

export const useScreenShare = (peerConnection) => {
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [screenStream, setScreenStream] = useState(null);

  const startScreenShare = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          cursor: 'always',
          displaySurface: 'monitor'
        },
        audio: true
      });

      setScreenStream(stream);
      setIsScreenSharing(true);

      // Replace video track in peer connection
      if (peerConnection) {
        const videoTrack = stream.getVideoTracks()[0];
        const sender = peerConnection.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        );
        
        if (sender) {
          await sender.replaceTrack(videoTrack);
        }
      }

      // Handle screen share end
      stream.getVideoTracks()[0].addEventListener('ended', () => {
        stopScreenShare();
      });

      return stream;
    } catch (error) {
      console.error('Error starting screen share:', error);
      throw error;
    }
  }, [peerConnection]);

  const stopScreenShare = useCallback(async () => {
    if (screenStream) {
      screenStream.getTracks().forEach(track => track.stop());
      setScreenStream(null);
      setIsScreenSharing(false);

      // Restore camera stream
      try {
        const cameraStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });

        if (peerConnection) {
          const videoTrack = cameraStream.getVideoTracks()[0];
          const sender = peerConnection.getSenders().find(s => 
            s.track && s.track.kind === 'video'
          );
          
          if (sender) {
            await sender.replaceTrack(videoTrack);
          }
        }

        return cameraStream;
      } catch (error) {
        console.error('Error restoring camera:', error);
        throw error;
      }
    }
  }, [screenStream, peerConnection]);

  return {
    isScreenSharing,
    screenStream,
    startScreenShare,
    stopScreenShare
  };
};
```

### Group Video Call Support
```javascript
// hooks/useGroupCall.js
import { useState, useRef, useCallback } from 'react';

export const useGroupCall = (socket) => {
  const [participants, setParticipants] = useState(new Map());
  const [roomId, setRoomId] = useState(null);
  const peerConnections = useRef(new Map());

  const createPeerConnection = useCallback((userId) => {
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    });

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit('ice-candidate', {
          candidate: event.candidate,
          to: userId
        });
      }
    };

    pc.ontrack = (event) => {
      const [stream] = event.streams;
      setParticipants(prev => new Map(prev.set(userId, {
        ...prev.get(userId),
        stream
      })));
    };

    peerConnections.current.set(userId, pc);
    return pc;
  }, [socket]);

  const joinRoom = useCallback(async (roomId, localStream) => {
    setRoomId(roomId);
    socket.emit('join-room', roomId);

    // Handle new participants
    socket.on('user-joined', async (data) => {
      const { userId } = data;
      const pc = createPeerConnection(userId);
      
      // Add local stream
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });

      // Create offer for new participant
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      socket.emit('call-user', {
        userToCall: userId,
        signalData: offer,
        from: socket.id
      });
    });

    // Handle existing participants
    socket.on('room-participants', async (participantsList) => {
      for (const participant of participantsList) {
        const pc = createPeerConnection(participant.userId);
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
    });

  }, [socket, createPeerConnection]);

  const leaveRoom = useCallback(() => {
    if (roomId) {
      socket.emit('leave-room', roomId);
      
      // Close all peer connections
      peerConnections.current.forEach(pc => pc.close());
      peerConnections.current.clear();
      
      setParticipants(new Map());
      setRoomId(null);
    }
  }, [socket, roomId]);

  return {
    participants,
    roomId,
    joinRoom,
    leaveRoom
  };
};
```

### Data Channel Communication
```javascript
// hooks/useDataChannel.js
import { useState, useRef, useCallback } from 'react';

export const useDataChannel = (peerConnection) => {
  const [isDataChannelOpen, setIsDataChannelOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const dataChannelRef = useRef(null);

  const setupDataChannel = useCallback(() => {
    if (!peerConnection) return;

    // Create data channel
    const dataChannel = peerConnection.createDataChannel('chat', {
      ordered: true,
      maxRetransmits: 3
    });

    dataChannel.onopen = () => {
      console.log('Data channel opened');
      setIsDataChannelOpen(true);
    };

    dataChannel.onclose = () => {
      console.log('Data channel closed');
      setIsDataChannelOpen(false);
    };

    dataChannel.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    dataChannel.onerror = (error) => {
      console.error('Data channel error:', error);
    };

    dataChannelRef.current = dataChannel;

    // Handle incoming data channels
    peerConnection.ondatachannel = (event) => {
      const channel = event.channel;
      
      channel.onopen = () => setIsDataChannelOpen(true);
      channel.onclose = () => setIsDataChannelOpen(false);
      channel.onmessage = (event) => {
        const message = JSON.parse(event.data);
        setMessages(prev => [...prev, message]);
      };
    };

  }, [peerConnection]);

  const sendMessage = useCallback((text) => {
    if (dataChannelRef.current && isDataChannelOpen) {
      const message = {
        id: Date.now(),
        text,
        timestamp: new Date().toISOString(),
        sender: 'local'
      };
      
      dataChannelRef.current.send(JSON.stringify(message));
      setMessages(prev => [...prev, message]);
    }
  }, [isDataChannelOpen]);

  const sendFile = useCallback(async (file) => {
    if (!dataChannelRef.current || !isDataChannelOpen) return;

    const chunkSize = 16384; // 16KB chunks
    const fileReader = new FileReader();
    
    // Send file metadata first
    const metadata = {
      type: 'file-start',
      name: file.name,
      size: file.size,
      mimeType: file.type
    };
    
    dataChannelRef.current.send(JSON.stringify(metadata));

    // Send file in chunks
    let offset = 0;
    
    const sendChunk = () => {
      const slice = file.slice(offset, offset + chunkSize);
      fileReader.readAsArrayBuffer(slice);
    };

    fileReader.onload = (event) => {
      dataChannelRef.current.send(event.target.result);
      offset += chunkSize;
      
      if (offset < file.size) {
        sendChunk();
      } else {
        // Send end marker
        dataChannelRef.current.send(JSON.stringify({ type: 'file-end' }));
      }
    };

    sendChunk();
  }, [isDataChannelOpen]);

  return {
    isDataChannelOpen,
    messages,
    setupDataChannel,
    sendMessage,
    sendFile
  };
};
```

---

## 9. Error Handling & Best Practices

### Comprehensive Error Handling
```javascript
// utils/error-handler.js
export class WebRTCError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'WebRTCError';
    this.code = code;
    this.details = details;
  }
}

export const ERROR_CODES = {
  MEDIA_ACCESS_DENIED: 'MEDIA_ACCESS_DENIED',
  PEER_CONNECTION_FAILED: 'PEER_CONNECTION_FAILED',
  SIGNALING_ERROR: 'SIGNALING_ERROR',
  ICE_CONNECTION_FAILED: 'ICE_CONNECTION_FAILED',
  NETWORK_ERROR: 'NETWORK_ERROR'
};

export const handleWebRTCError = (error) => {
  console.error('WebRTC Error:', error);
  
  switch (error.name) {
    case 'NotAllowedError':
      return new WebRTCError(
        'Camera/microphone access denied. Please allow permissions and try again.',
        ERROR_CODES.MEDIA_ACCESS_DENIED,
        { originalError: error }
      );
      
    case 'NotFoundError':
      return new WebRTCError(
        'No camera or microphone found. Please check your devices.',
        ERROR_CODES.MEDIA_ACCESS_DENIED,
        { originalError: error }
      );
      
    case 'OverconstrainedError':
      return new WebRTCError(
        'Camera/microphone constraints not supported. Trying with default settings.',
        ERROR_CODES.MEDIA_ACCESS_DENIED,
        { originalError: error }
      );
      
    default:
      return new WebRTCError(
        'An unexpected error occurred. Please try again.',
        ERROR_CODES.NETWORK_ERROR,
        { originalError: error }
      );
  }
};
```

### Error Boundary Component
```javascript
// components/ErrorBoundary.js
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error boundary caught an error:', error, errorInfo);
    
    // Report to error tracking service
    if (window.gtag) {
      window.gtag('event', 'exception', {
        description: error.toString(),
        fatal: false
      });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-gray-100 flex items-center justify-center">
          <div className="bg-white p-8 rounded-lg shadow-md max-w-md w-full">
            <div className="text-center">
              <svg className="mx-auto h-12 w-12 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
              <h2 className="mt-4 text-lg font-semibold text-gray-900">Something went wrong</h2>
              <p className="mt-2 text-sm text-gray-600">
                We're sorry, but something unexpected happened. Please refresh the page and try again.
              </p>
              <button
                onClick={() => window.location.reload()}
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
              >
                Refresh Page
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

### Best Practices Implementation
```javascript
// hooks/useWebRTCWithBestPractices.js
import { useState, useCallback, useRef, useEffect } from 'react';
import { handleWebRTCError } from '../utils/error-handler';

export const useWebRTCWithBestPractices = (socket) => {
  const [connectionState, setConnectionState] = useState('new');
  const [error, setError] = useState(null);
  const connectionTimeoutRef = useRef(null);
  const heartbeatIntervalRef = useRef(null);

  // Connection monitoring
  const monitorConnection = useCallback((peerConnection) => {
    peerConnection.onconnectionstatechange = () => {
      const state = peerConnection.connectionState;
      setConnectionState(state);
      
      switch (state) {
        case 'connected':
          // Start heartbeat
          heartbeatIntervalRef.current = setInterval(() => {
            if (peerConnection.connectionState === 'connected') {
              // Send heartbeat via data channel
              try {
                const dataChannel = peerConnection.getDataChannels?.()?.[0];
                if (dataChannel && dataChannel.readyState === 'open') {
                  dataChannel.send(JSON.stringify({ type: 'heartbeat' }));
                }
              } catch (error) {
                console.warn('Heartbeat failed:', error);
              }
            }
          }, 30000);
          break;
          
        case 'disconnected':
          // Attempt reconnection
          setTimeout(() => {
            if (peerConnection.connectionState === 'disconnected') {
              console.log('Attempting to restart ICE');
              peerConnection.restartIce();
            }
          }, 5000);
          break;
          
        case 'failed':
          setError(new Error('Connection failed'));
          break;
      }
    };
  }, []);

  // Graceful degradation for older browsers
  const checkWebRTCSupport = useCallback(() => {
    if (!window.RTCPeerConnection) {
      throw new Error('WebRTC is not supported in this browser');
    }
    
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('Media devices not supported');
    }
  }, []);

  // Progressive media constraints
  const getMediaWithFallback = useCallback(async () => {
    const constraints = [
      // High quality
      {
        video: { width: 1280, height: 720, frameRate: 30 },
        audio: { echoCancellation: true, noiseSuppression: true }
      },
      // Medium quality
      {
        video: { width: 640, height: 480, frameRate: 24 },
        audio: { echoCancellation: true }
      },
      // Low quality
      {
        video: { width: 320, height: 240, frameRate: 15 },
        audio: true
      },
      // Audio only
      {
        video: false,
        audio: true
      }
    ];

    for (const constraint of constraints) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraint);
        console.log('Media obtained with constraints:', constraint);
        return stream;
      } catch (error) {
        console.warn('Failed with constraints:', constraint, error);
        continue;
      }
    }
    
    throw new Error('Could not obtain media with any constraints');
  }, []);

  // Cleanup function
  const cleanup = useCallback(() => {
    if (connectionTimeoutRef.current) {
      clearTimeout(connectionTimeoutRef.current);
    }
    
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
    }
  }, []);

  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  return {
    connectionState,
    error,
    checkWebRTCSupport,
    getMediaWithFallback,
    monitorConnection,
    handleWebRTCError
  };
};
```

---

## 10. Security Considerations

### Secure Signaling Implementation
```javascript
// utils/security.js
import crypto from 'crypto';

export const generateSecureRoomId = () => {
  return crypto.randomBytes(16).toString('hex');
};

export const validateMessage = (message) => {
  // Implement message validation
  if (!message || typeof message !== 'object') {
    throw new Error('Invalid message format');
  }
  
  // Check for XSS attempts
  const dangerousPatterns = [
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=/gi
  ];
  
  const messageStr = JSON.stringify(message);
  dangerousPatterns.forEach(pattern => {
    if (pattern.test(messageStr)) {
      throw new Error('Potentially malicious content detected');
    }
  });
  
  return true;
};

export const sanitizeUserInput = (input) => {
  if (typeof input !== 'string') return input;
  
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
};

// Rate limiting for signaling
export class RateLimiter {
  constructor(maxRequests = 100, windowMs = 60000) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.clients = new Map();
  }
  
  isAllowed(clientId) {
    const now = Date.now();
    const client = this.clients.get(clientId) || { requests: [], blocked: false };
    
    // Clean old requests
    client.requests = client.requests.filter(time => now - time < this.windowMs);
    
    if (client.requests.length >= this.maxRequests) {
      client.blocked = true;
      return false;
    }
    
    client.requests.push(now);
    this.clients.set(clientId, client);
    return true;
  }
}
```

### Secure Authentication
```javascript
// server/auth.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

class AuthManager {
  constructor(secretKey) {
    this.secretKey = secretKey;
    this.connectedUsers = new Map();
  }
  
  generateToken(user) {
    return jwt.sign(
      { 
        userId: user.id, 
        username: user.username,
        exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour
      },
      this.secretKey
    );
  }
  
  verifyToken(token) {
    try {
      return jwt.verify(token, this.secretKey);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
  
  authenticateSocket(socket, next) {
    const token = socket.handshake.auth?.token;
    
    if (!token) {
      return next(new Error('Authentication token required'));
    }
    
    try {
      const decoded = this.verifyToken(token);
      socket.userId = decoded.userId;
      socket.username = decoded.username;
      next();
    } catch (error) {
      next(new Error('Authentication failed'));
    }
  }
}

module.exports = AuthManager;
```

### HTTPS and WSS Configuration
```javascript
// server/secure-server.js
const https = require('https');
const fs = require('fs');
const path = require('path');

const createSecureServer = (app) => {
  const options = {
    key: fs.readFileSync(path.join(__dirname, '../ssl/private.key')),
    cert: fs.readFileSync(path.join(__dirname, '../ssl/certificate.crt')),
    // Optional: Certificate chain
    ca: fs.readFileSync(path.join(__dirname, '../ssl/ca_bundle.crt'))
  };
  
  return https.createServer(options, app);
};

// Socket.io with secure transport
const secureSocketConfig = {
  cors: {
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ["https://yourdomain.com"],
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket'], // Only secure websockets
  allowEIO3: false // Disable older Engine.IO versions
};

module.exports = { createSecureServer, secureSocketConfig };
```

---

## 11. Deployment & Production

### Production Environment Setup
```yaml
# docker-compose.yml
version: '3.8'

services:
  webrtc-app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REACT_APP_SERVER_URL=wss://yourdomain.com
    volumes:
      - ./ssl:/app/ssl:ro

  signaling-server:
    build: ./server
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=production
      - PORT=5000
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - ./ssl:/app/ssl:ro
    depends_on:
      - redis

  coturn:
    image: coturn/coturn:latest
    ports:
      - "3478:3478"
      - "3478:3478/udp"
      - "5349:5349"
      - "5349:5349/udp"
      - "49152-65535:49152-65535/udp"
    volumes:
      - ./coturn/turnserver.conf:/etc/coturn/turnserver.conf:ro
      - ./ssl:/etc/ssl:ro
    network_mode: host

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  redis_data:
```

### Production Dockerfile
```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine

# Copy built app
COPY --from=builder /app/build /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf

# Copy SSL certificates
COPY ssl/ /etc/ssl/

EXPOSE 80 443

CMD ["nginx", "-g", "daemon off;"]
```

### Nginx Configuration
```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # Redirect HTTP to HTTPS
    server {
        listen 80;
        server_name yourdomain.com;
        return 301 https://$server_name$request_uri;
    }

    # HTTPS Server
    server {
        listen 443 ssl http2;
        server_name yourdomain.com;

        ssl_certificate /etc/ssl/certificate.crt;
        ssl_certificate_key /etc/ssl/private.key;

        root /usr/share/nginx/html;
        index index.html;

        # Security headers
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;

        # API proxy
        location /api/ {
            proxy_pass https://signaling-server:5000/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # WebSocket proxy for Socket.io
        location /socket.io/ {
            proxy_pass https://signaling-server:5000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # React app
        location / {
            try_files $uri $uri/ /index.html;
        }
    }
}
```

### Environment Configuration
```bash
# .env.production
NODE_ENV=production
REACT_APP_SERVER_URL=wss://yourdomain.com
REACT_APP_TURN_SERVER=turns:yourdomain.com:5349
REACT_APP_STUN_SERVER=stun:yourdomain.com:3478

# Server environment
JWT_SECRET=your_super_secure_jwt_secret_here
TURN_USERNAME=your_turn_username
TURN_PASSWORD=your_turn_password
REDIS_URL=redis://redis:6379
```

---

## 12. Troubleshooting Guide

### Common Issues and Solutions

#### 1. Camera/Microphone Access Issues
```javascript
// utils/media-troubleshoot.js
export const troubleshootMediaAccess = async () => {
  const issues = [];
  
  // Check if running on HTTPS
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    issues.push({
      type: 'security',
      message: 'Media access requires HTTPS in production',
      solution: 'Serve your application over HTTPS'
    });
  }
  
  // Check browser support
  if (!navigator.mediaDevices) {
    issues.push({
      type: 'compatibility',
      message: 'MediaDevices API not supported',
      solution: 'Use a modern browser that supports WebRTC'
    });
  }
  
  // Test media access
  try {
    await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
  } catch (error) {
    switch (error.name) {
      case 'NotAllowedError':
        issues.push({
          type: 'permission',
          message: 'Camera/microphone access denied',
          solution: 'Allow camera and microphone permissions in browser settings'
        });
        break;
      case 'NotFoundError':
        issues.push({
          type: 'hardware',
          message: 'No camera or microphone found',
          solution: 'Connect a camera/microphone and refresh the page'
        });
        break;
    }
  }
  
  return issues;
};
```

#### 2. Connection Issues
```javascript
// utils/connection-troubleshoot.js
export const troubleshootConnection = async (iceServers) => {
  const results = {
    stun: false,
    turn: false,
    network: 'unknown'
  };
  
  try {
    const pc = new RTCPeerConnection({ iceServers });
    const candidates = [];
    
    return new Promise((resolve) => {
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          candidates.push(event.candidate);
          
          // Check candidate types
          if (event.candidate.type === 'srflx') {
            results.stun = true;
          }
          if (event.candidate.type === 'relay') {
            results.turn = true;
          }
        } else {
          // Determine network type
          const hasHost = candidates.some(c => c.type === 'host');
          const hasSrflx = candidates.some(c => c.type === 'srflx');
          const hasRelay = candidates.some(c => c.type === 'relay');
          
          if (hasHost && hasSrflx) {
            results.network = 'open';
          } else if (hasHost && !hasSrflx) {
            results.network = 'restricted';
          } else if (hasRelay) {
            results.network = 'blocked';
          }
          
          pc.close();
          resolve(results);
        }
      };
      
      pc.createDataChannel('test');
      pc.createOffer().then(offer => pc.setLocalDescription(offer));
      
      setTimeout(() => {
        pc.close();
        resolve(results);
      }, 10000);
    });
  } catch (error) {
    console.error('Connection test failed:', error);
    return results;
  }
};
```

#### 3. Performance Issues
```javascript
// utils/performance-monitor.js
export class PerformanceMonitor {
  constructor(peerConnection) {
    this.peerConnection = peerConnection;
    this.stats = new Map();
    this.monitoring = false;
  }
  
  startMonitoring() {
    if (this.monitoring) return;
    
    this.monitoring = true;
    this.monitorStats();
  }
  
  stopMonitoring() {
    this.monitoring = false;
  }
  
  async monitorStats() {
    if (!this.monitoring || !this.peerConnection) return;
    
    try {
      const stats = await this.peerConnection.getStats();
      const currentStats = this.parseStats(stats);
      
      // Check for issues
      this.detectIssues(currentStats);
      
      // Store stats
      this.stats.set(Date.now(), currentStats);
      
      // Keep only last 60 seconds of stats
      const cutoff = Date.now() - 60000;
      for (const [timestamp] of this.stats) {
        if (timestamp < cutoff) {
          this.stats.delete(timestamp);
        }
      }
      
    } catch (error) {
      console.error('Stats monitoring error:', error);
    }
    
    if (this.monitoring) {
      setTimeout(() => this.monitorStats(), 1000);
    }
  }
  
  parseStats(stats) {
    const result = {
      video: { inbound: null, outbound: null },
      audio: { inbound: null, outbound: null },
      connection: null
    };
    
    stats.forEach(stat => {
      switch (stat.type) {
        case 'inbound-rtp':
          if (stat.mediaType === 'video') {
            result.video.inbound = {
              packetsReceived: stat.packetsReceived,
              packetsLost: stat.packetsLost,
              bytesReceived: stat.bytesReceived,
              framesDecoded: stat.framesDecoded
            };
          } else if (stat.mediaType === 'audio') {
            result.audio.inbound = {
              packetsReceived: stat.packetsReceived,
              packetsLost: stat.packetsLost,
              bytesReceived: stat.bytesReceived
            };
          }
          break;
          
        case 'outbound-rtp':
          if (stat.mediaType === 'video') {
            result.video.outbound = {
              packetsSent: stat.packetsSent,
              bytesSent: stat.bytesSent,
              framesEncoded: stat.framesEncoded
            };
          } else if (stat.mediaType === 'audio') {
            result.audio.outbound = {
              packetsSent: stat.packetsSent,
              bytesSent: stat.bytesSent
            };
          }
          break;
          
        case 'candidate-pair':
          if (stat.state === 'succeeded') {
            result.connection = {
              roundTripTime: stat.currentRoundTripTime,
              availableOutgoingBitrate: stat.availableOutgoingBitrate,
              availableIncomingBitrate: stat.availableIncomingBitrate
            };
          }
          break;
      }
    });
    
    return result;
  }
  
  detectIssues(stats) {
    const issues = [];
    
    // Check packet loss
    if (stats.video.inbound?.packetsLost > 0) {
      const lossRate = stats.video.inbound.packetsLost / 
                      (stats.video.inbound.packetsReceived + stats.video.inbound.packetsLost);
      if (lossRate > 0.02) { // 2% packet loss
        issues.push({
          type: 'packet-loss',
          severity: lossRate > 0.05 ? 'high' : 'medium',
          message: `High packet loss detected: ${(lossRate * 100).toFixed(1)}%`
        });
      }
    }
    
    // Check round trip time
    if (stats.connection?.roundTripTime > 0.5) { // 500ms
      issues.push({
        type: 'high-latency',
        severity: 'medium',
        message: `High latency detected: ${(stats.connection.roundTripTime * 1000).toFixed(0)}ms`
      });
    }
    
    // Check bandwidth
    if (stats.connection?.availableOutgoingBitrate < 100000) { // 100kbps
      issues.push({
        type: 'low-bandwidth',
        severity: 'high',
        message: 'Low bandwidth detected, video quality may be poor'
      });
    }
    
    if (issues.length > 0) {
      this.onIssuesDetected?.(issues);
    }
  }
}
```

### Debug Helper Component
```javascript
// components/DebugPanel.js
import React, { useState, useEffect } from 'react';

const DebugPanel = ({ peerConnection, socket }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [stats, setStats] = useState(null);
  const [logs, setLogs] = useState([]);

  useEffect(() => {
    if (!peerConnection) return;

    const interval = setInterval(async () => {
      try {
        const stats = await peerConnection.getStats();
        const parsedStats = parseWebRTCStats(stats);
        setStats(parsedStats);
      } catch (error) {
        console.error('Failed to get stats:', error);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [peerConnection]);

  const parseWebRTCStats = (stats) => {
    // Parse and format stats for display
    const result = { candidates: [], streams: [] };
    
    stats.forEach(stat => {
      if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {
        result.activeCandidatePair = stat;
      }
      if (stat.type === 'inbound-rtp') {
        result.streams.push({
          type: 'inbound',
          mediaType: stat.mediaType,
          packetsReceived: stat.packetsReceived,
          packetsLost: stat.packetsLost,
          bytesReceived: stat.bytesReceived
        });
      }
    });
    
    return result;
  };

  if (!isOpen) {
    return (
      <button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-4 left-4 bg-gray-800 text-white px-3 py-2 rounded text-sm"
      >
        Debug
      </button>
    );
  }

  return (
    <div className="fixed bottom-4 left-4 bg-white border rounded-lg shadow-lg p-4 w-96 max-h-80 overflow-y-auto">
      <div className="flex justify-between items-center mb-2">
        <h3 className="font-bold">Debug Panel</h3>
        <button onClick={() => setIsOpen(false)} className="text-gray-500">×</button>
      </div>
      
      <div className="space-y-2 text-xs">
        <div>
          <strong>Connection State:</strong> {peerConnection?.connectionState}
        </div>
        <div>
          <strong>ICE State:</strong> {peerConnection?.iceConnectionState}
        </div>
        <div>
          <strong>Socket Connected:</strong> {socket?.connected ? 'Yes' : 'No'}
        </div>
        
        {stats?.activeCandidatePair && (
          <div>
            <strong>RTT:</strong> {(stats.activeCandidatePair.currentRoundTripTime * 1000).toFixed(0)}ms
          </div>
        )}
        
        {stats?.streams?.map((stream, index) => (
          <div key={index}>
            <strong>{stream.type} {stream.mediaType}:</strong> 
            {stream.packetsReceived} packets, {stream.packetsLost} lost
          </div>
        ))}
      </div>
    </div>
  );
};

export default DebugPanel;
```

---

## Conclusion

This comprehensive guide provides you with everything needed to implement WebRTC video calling in React.js. Key takeaways:

1. **Signaling is Critical**: WebRTC uses ICE (Interactive Connection Establishment) framework to find the best path to connect the peers. When the direct connection fails, there must be a way for the peers to establish a connection. This is where STUN and TURN come into picture.

2. **Error Handling**: Error handling: Implement informative error messages and recovery strategies. For example, check that data-processing functions properly handle invalid inputs and log errors.

3. **Security First**: To ensure your React WebRTC application is efficient and secure, follow best practices such as using proper error handling, securing your signaling with WebSockets over TLS, and minimizing the use of the global state.

4. **Production Ready**: Implement proper monitoring, STUN/TURN servers, and security measures for production deployment.

The implementation covers peer-to-peer video calling, group calls, screen sharing, data channels, and comprehensive error handling. With this foundation, you can build robust real-time communication applications using React.js and WebRTC.